<!DOCTYPE html>
<html>
<head>
  <title>PaintMusic - Personal Blog</title>
  <link rel="icon" type="image/png" sizes="32x32" href="favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon.png">
  <link rel="shortcut icon" href="favicon.png">
  <link rel="apple-touch-icon" href="favicon.png">
  <link rel="stylesheet" href="style.css">
  <!-- Security Headers -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://www.gstatic.com https://www.googleapis.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https: http:; font-src 'self' data:; connect-src 'self' https://www.googleapis.com https://*.googleapis.com https://*.firebaseio.com https://*.firebase.com wss://*.firebaseio.com https://kam-budless-gael.ngrok-free.dev; frame-src https://www.youtube.com; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none';">
  <meta http-equiv="X-Frame-Options" content="DENY">
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
</head>
<body>
  <div class="wrapper-retro">
    <div class="header-retro">
      <div class="header-container">
        <img src="https://media1.tenor.com/m/-v0gLfm3FtEAAAAd/chuzzle-raptisoft.gif" alt="chuzzle" class="chuzzle-left">
        <div class="header-center">
          <img src="logo.png" alt="Paint's Music Page" class="header-logo">
          <div class="blink">i love music and chuzzle</div>
          <div id="userLink" class="user-status"><a href="login.html">login</a></div>
          <div class="online-counter">ONLINE: <span id="onlineCount">0</span> <img src="users-online.png" alt="users" class="users-icon"></div>
        </div>
        <img src="https://media1.tenor.com/m/-v0gLfm3FtEAAAAd/chuzzle-raptisoft.gif" alt="chuzzle" class="chuzzle-right">
      </div>
    </div>

    <div class="nav-center">
  <a href="index.html"><img src="album-reviews.png" alt="Album Reviews" class="nav-img"></a>
  <a href="interviews.html"><img src="interviews.png" alt="Interviews" class="nav-img"></a>
  <a href="blog.html"><img src="personal-blog.png" alt="Personal Blog" class="nav-img"></a>
</div>

    <div class="main-container">
      <div class="content-retro">
        <div class="blog-header">
          <img src="personal-blog.png" alt="Personal Blog" class="blog-title-logo">
          <button id="newPostBtn" onclick="showNewPostForm()" style="display: none;">New Post</button>
        </div>

        <div id="postsContainer"></div>
      </div>
    </div>

    <div id="newPostModal" class="modal">
      <div class="modal-content">
        <h2>New Post</h2>
        <form onsubmit="return false;">
          <textarea id="postContent" rows="6" placeholder="What's on your mind?" required></textarea>
          
          <div class="image-upload-container">
            <label style="color: #ffff00; display: block; margin: 15px 0 5px 0; font-weight: bold;">Upload Image (optional):</label>
            <input type="file" id="postImageInput" accept="image/*" onchange="previewPostImage(event)">
            <img id="postImagePreview" class="image-preview" style="display: none;">
          </div>
          
          <div class="modal-buttons">
            <button type="button" onclick="submitNewPost()">Post</button>
            <button type="button" onclick="hideNewPostForm()">Cancel</button>
          </div>
        </form>
      </div>
    </div>

    <div class="footer">
      &copy; paintmusic<br>
      i luv u chuzzle
    </div>
  </div>

  <script type="module" src="firebase.js"></script>
  <script type="module" src="userbar.js"></script>
  <script type="module" src="online-counter.js"></script>
  <script type="module" src="blog.js"></script>

  <!-- Radio and Chatroom Container -->
  <div class="radio-chat-wrapper" id="radioChatWrapper">
    <div class="music-player" id="musicPlayer">
    <div class="player-header" id="playerHeader">
      <div class="player-title">PAINTYUM RADIO</div>
      <div class="player-controls-top">
        <button onclick="toggleMinimize()" class="minimize-btn">_</button>
      </div>
    </div>
    
    <div class="player-content" id="playerContent">
      <div class="player-display">
        <div class="player-time" id="playerStatus">⚫ OFFLINE</div>
        <div class="player-station">PAINTYUM RADIO</div>
        <div class="player-track">Waiting for stream...</div>
      </div>
      
      <div class="player-buttons">
        <button onclick="previousTrack()" title="Previous">⏮</button>
        <button onclick="togglePlay()" id="playBtn" title="Play">▶</button>
        <button onclick="stopStream()" title="Stop">⏹</button>
        <button onclick="nextTrack()" title="Next">⏭</button>
      </div>
      
      <div class="volume-control">
        <span>Volume</span>
        <input type="range" min="0" max="100" value="80" id="volumeSlider" onchange="changeVolume(this.value)">
        <span id="volumeDisplay">80</span>
      </div>
    </div>
    </div>

    <!-- Chatroom Section -->
    <div class="chat-container" id="chatContainer">
      <div class="chat-users-sidebar" id="chatUsersSidebar">
        <div class="chat-users-title">USERS</div>
        <div class="chat-users-list" id="chatUsersList"></div>
      </div>
      <div class="chat-main">
        <div class="chat-header">
          <span>CHATROOM</span>
          <div>
            <button onclick="openShopModal()" style="background: #0066cc; color: #ffff00; padding: 5px 10px; border: 2px solid #00ffff; cursor: pointer; font-size: 11px; margin-left: 10px;">SHOP</button>
            <button id="untimeoutBtn" onclick="showUntimeoutModal()" style="display: none; background: #00ff00; color: #000; padding: 5px 10px; border: none; cursor: pointer; font-size: 11px; margin-left: 10px;">Untimeout</button>
            <button id="unbanBtn" onclick="showUnbanModal()" style="display: none; background: #ffaa00; color: #000; padding: 5px 10px; border: none; cursor: pointer; font-size: 11px; margin-left: 10px;">Unban</button>
          </div>
        </div>
        <div class="chat-messages" id="chatMessages"></div>
        <div class="chat-login-message" id="loginMessage">Please log in to chat</div>
        <div class="chat-input-container" id="chatInputContainer" style="display: none;">
          <button id="gifPickerBtn" onclick="openGifPicker('chat')">GIF</button>
          <input type="text" id="chatInput" class="chat-input" placeholder="Type your message...">
          <button onclick="sendMessage()" class="chat-send-btn">Send</button>
        </div>
        <div class="xp-bar-container" id="xpBarContainer" style="display: none;">
          <div class="xp-bar-info">
            <span class="xp-level-text" id="xpLevelText">LV 1</span>
            <span class="xp-progress-text" id="xpProgressText">0 / 100 messages</span>
          </div>
          <div class="xp-bar-wrapper">
            <div class="xp-bar-fill" id="xpBarFill" style="width: 0%;"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Untimeout Modal -->
    <div id="untimeoutModal" class="chat-modal" style="display: none;">
      <div class="chat-modal-content">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
          <h3 style="margin: 0; color: #00ffff;">Untimeout Users</h3>
          <button onclick="closeUntimeoutModal()" style="background: #cc0000; color: #fff; border: none; padding: 5px 10px; cursor: pointer;">Close</button>
        </div>
        <div id="untimeoutModalContent"></div>
      </div>
    </div>

    <!-- Unban Modal -->
    <div id="unbanModal" class="chat-modal" style="display: none;">
      <div class="chat-modal-content">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
          <h3 style="margin: 0; color: #00ffff;">Banned Usernames</h3>
          <button onclick="closeUnbanModal()" style="background: #cc0000; color: #fff; border: none; padding: 5px 10px; cursor: pointer;">Close</button>
        </div>
        <div id="unbanModalContent"></div>
      </div>
    </div>
    </div>
  </div>

  <audio id="radioStream" preload="auto"></audio>

  <script type="module" src="chat.js"></script>
  <script type="module" src="shop-modal.js"></script>
  <script type="module" src="gif-picker.js"></script>

  <script>
    const audio = document.getElementById('radioStream');
    const playBtn = document.getElementById('playBtn');
    const playerContent = document.getElementById('playerContent');
    const musicPlayer = document.getElementById('musicPlayer');
    const radioChatWrapper = document.getElementById('radioChatWrapper');
    
    // Radio server configuration
    // For local network access, use your local IP (192.168.86.28)
    // For internet access via ngrok, the code will auto-detect the ngrok URL
    
    // LOCAL NETWORK ACCESS (same WiFi/network):
    const LOCAL_IP = '192.168.86.28'; // Your local network IP
    
    // Auto-detect: use localhost if on same machine, otherwise use local IP
    let RADIO_HOST = LOCAL_IP;
    let RADIO_PORT = 8000;
    let USE_HTTPS = false;
    
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || window.location.hostname === '') {
      RADIO_HOST = 'localhost';
    }
    
    // Try to auto-detect ngrok URL (if ngrok is running)
    async function detectNgrokUrl() {
      try {
        const response = await fetch('http://127.0.0.1:4040/api/tunnels');
        const data = await response.json();
        
        if (data.tunnels && data.tunnels.length > 0) {
          // Find the tunnel that forwards to localhost:8000
          const tunnel = data.tunnels.find(t => 
            t.config.addr && t.config.addr.includes('8000')
          ) || data.tunnels[0]; // Fallback to first tunnel
          
          if (tunnel && tunnel.public_url) {
            const ngrokUrl = tunnel.public_url;
            console.log('Auto-detected ngrok URL:', ngrokUrl);
            
            // Use ngrok URL
            RADIO_HOST = ngrokUrl.replace('https://', '').replace('http://', '');
            RADIO_PORT = '';
            USE_HTTPS = ngrokUrl.startsWith('https://');
            
            // Update audio source
            const PROTOCOL = USE_HTTPS ? 'https' : 'http';
            const PORT_STRING = RADIO_PORT ? `:${RADIO_PORT}` : '';
            const STREAM_URL = `${PROTOCOL}://${RADIO_HOST}${PORT_STRING}/stream`;
            const STATUS_URL = `${PROTOCOL}://${RADIO_HOST}${PORT_STRING}/status-json.xsl`;
            
            const streamUrl = window.STREAM_URL || STREAM_URL;
        audio.src = streamUrl;
            window.STREAM_URL = STREAM_URL;
            window.STATUS_URL = STATUS_URL;
            
            console.log('Radio server URL (ngrok):', STREAM_URL);
            return true;
          }
        }
      } catch (err) {
        // ngrok not running or not accessible, use local network
        console.log('ngrok not detected, using local network:', err.message);
      }
      return false;
    }
    
    // Initialize radio URLs
    let STREAM_URL, STATUS_URL;
    
    // Try to get ngrok URL from Firebase (auto-updates without code changes)
    async function getNgrokUrlFromFirebase() {
      try {
        const { getDoc, doc } = await import("https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js");
        const { db } = await import('./firebase.js');
        const configDoc = await getDoc(doc(db, 'config', 'radio'));
        if (configDoc.exists()) {
          const data = configDoc.data();
          if (data.ngrokUrl) {
            console.log('Got ngrok URL from Firebase:', data.ngrokUrl);
            return data.ngrokUrl;
          }
        }
      } catch (err) {
        console.log('Could not get ngrok URL from Firebase:', err.message);
      }
      return null;
    }
    
    // If site is HTTPS, we MUST use HTTPS stream (ngrok)
    const isHttpsSite = window.location.protocol === 'https:';
    
    // Try to detect ngrok first, then fall back to Firebase, then local network
    detectNgrokUrl().then(async (ngrokFound) => {
      if (!ngrokFound) {
        // Try to get from Firebase
        const firebaseNgrokUrl = await getNgrokUrlFromFirebase();
        
        if (firebaseNgrokUrl) {
          // Use ngrok URL from Firebase
          RADIO_HOST = firebaseNgrokUrl.replace('https://', '').replace('http://', '');
          RADIO_PORT = '';
          USE_HTTPS = firebaseNgrokUrl.startsWith('https://');
          STREAM_URL = `${USE_HTTPS ? 'https' : 'http'}://${RADIO_HOST}/stream`;
          STATUS_URL = `${USE_HTTPS ? 'https' : 'http'}://${RADIO_HOST}/status-json.xsl`;
          const streamUrl = window.STREAM_URL || STREAM_URL;
          audio.src = streamUrl;
          window.STREAM_URL = STREAM_URL;
          window.STATUS_URL = STATUS_URL;
          console.log('Using ngrok URL from Firebase:', STREAM_URL);
        } else if (isHttpsSite) {
          // HTTPS site needs HTTPS stream - warn user
          console.error('ERROR: HTTPS site requires ngrok URL. Please set it in Firebase config/radio document.');
        } else {
          // Use local network (only works on HTTP sites or localhost)
          const PROTOCOL = USE_HTTPS ? 'https' : 'http';
          const PORT_STRING = RADIO_PORT ? `:${RADIO_PORT}` : '';
          STREAM_URL = `${PROTOCOL}://${RADIO_HOST}${PORT_STRING}/stream`;
          STATUS_URL = `${PROTOCOL}://${RADIO_HOST}${PORT_STRING}/status-json.xsl`;
          const streamUrl = window.STREAM_URL || STREAM_URL;
          audio.src = streamUrl;
          window.STREAM_URL = STREAM_URL;
          window.STATUS_URL = STATUS_URL;
          console.log('Radio server URL (local network):', STREAM_URL);
        }
      }
    });
    
    // Set initial URLs (will be updated if ngrok is found)
    const PROTOCOL = USE_HTTPS ? 'https' : 'http';
    const PORT_STRING = RADIO_PORT ? `:${RADIO_PORT}` : '';
    STREAM_URL = `${PROTOCOL}://${RADIO_HOST}${PORT_STRING}/stream`;
    STATUS_URL = `${PROTOCOL}://${RADIO_HOST}${PORT_STRING}/status-json.xsl`;
    window.STREAM_URL = STREAM_URL;
    window.STATUS_URL = STATUS_URL;
    
    let isPlaying = false;
    let isMinimized = false;
    let streamIsLive = false;
    
    audio.src = STREAM_URL;
    audio.volume = 0.8;
    
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    let xOffset = 0;
    let yOffset = 0;

    const playerHeader = document.getElementById('playerHeader');
    const chatContainer = document.getElementById('chatContainer');

    // Ensure chat container is visible on page load
    if (chatContainer) {
      chatContainer.style.display = 'flex';
    }

    // Set default centered position if no saved position exists
    const savedLeft = localStorage.getItem('radioChatWrapperLeft');
    const savedTop = localStorage.getItem('radioChatWrapperTop');
    if (!savedLeft || !savedTop) {
      // Center the radio vertically and horizontally on page load
      const centerX = window.innerWidth / 2 - 250; // 250 is half of 500px width
      const centerY = window.innerHeight / 2 - 200; // Approximate center (adjust as needed)
      radioChatWrapper.style.setProperty('left', centerX + 'px', 'important');
      radioChatWrapper.style.setProperty('top', centerY + 'px', 'important');
      radioChatWrapper.style.setProperty('position', 'absolute', 'important');
    } else {
      // Load saved position
      radioChatWrapper.style.setProperty('left', savedLeft, 'important');
      radioChatWrapper.style.setProperty('top', savedTop, 'important');
      radioChatWrapper.style.setProperty('position', 'absolute', 'important');
    }

    // Make both header and chat container draggable
    playerHeader.addEventListener('mousedown', dragStart);
    if (chatContainer) {
      chatContainer.addEventListener('mousedown', dragStart);
    }
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', dragEnd);

    function dragStart(e) {
      // Don't drag if clicking buttons or input fields
      if (e.target.classList.contains('minimize-btn') || 
          e.target.tagName === 'BUTTON' || 
          e.target.tagName === 'INPUT' ||
          e.target.closest('button') ||
          e.target.closest('input')) {
        return;
      }
      
      // Get current position relative to document
      const rect = radioChatWrapper.getBoundingClientRect();
      const scrollX = window.scrollX || window.pageXOffset;
      const scrollY = window.scrollY || window.pageYOffset;
      const currentLeft = rect.left + scrollX;
      const currentTop = rect.top + scrollY;
      initialX = e.clientX - currentLeft;
      initialY = e.clientY - currentTop;
      isDragging = true;
      
      if (e.target.closest('#playerHeader')) {
        playerHeader.style.cursor = 'grabbing';
      }
      if (chatContainer) {
        chatContainer.style.cursor = 'grabbing';
      }
    }

    function drag(e) {
      if (isDragging) {
        e.preventDefault();
        
        // Calculate new position relative to document
        currentX = e.clientX - initialX + window.scrollX;
        currentY = e.clientY - initialY + window.scrollY;
        
        // Update position - use absolute positioning relative to document
        radioChatWrapper.style.setProperty('left', currentX + 'px', 'important');
        radioChatWrapper.style.setProperty('top', currentY + 'px', 'important');
        radioChatWrapper.style.setProperty('position', 'absolute', 'important');
      }
    }

    function dragEnd(e) {
      if (isDragging) {
        // Store final position relative to document
        const finalX = e.clientX - initialX + window.scrollX;
        const finalY = e.clientY - initialY + window.scrollY;
        radioChatWrapper.style.setProperty('left', finalX + 'px', 'important');
        radioChatWrapper.style.setProperty('top', finalY + 'px', 'important');
        // Save position to localStorage
        localStorage.setItem('radioChatWrapperLeft', finalX + 'px');
        localStorage.setItem('radioChatWrapperTop', finalY + 'px');
      }
      isDragging = false;
      playerHeader.style.cursor = 'move';
      if (chatContainer) {
        chatContainer.style.cursor = 'default';
      }
    }
    
    async function checkStreamStatus() {
      // CORS prevents fetch requests, so we rely entirely on audio element events
      // HTML5 audio can play streams even with CORS errors
      const streamUrl = window.STREAM_URL || STREAM_URL;
      
      // Ensure audio source is set
      if (streamUrl && (!audio.src || audio.src !== streamUrl)) {
        audio.src = streamUrl;
        console.log('Audio source set to:', streamUrl);
      }
      
      // Check audio element state to determine if stream is live
      // If audio is playing or ready, stream is likely live
      if (!audio.paused && !audio.ended && audio.readyState >= 2) {
        if (!streamIsLive) {
          streamIsLive = true;
          document.getElementById('playerStatus').innerHTML = '● LIVE';
          console.log('Stream detected as LIVE (audio playing)');
        }
        return true;
      }
      
      return streamIsLive;
    }
    
    function updateTrackInfo(title) {
      const trackElement = document.querySelector('.player-track');
      if (trackElement) {
        if (title && title.trim() && title !== 'Live Radio Stream' && title !== 'unknown' && title.trim() !== '') {
          trackElement.textContent = title.trim();
        } else {
          // Don't change to "No track info available" if we already have a song name
          if (trackElement.textContent === 'Waiting for stream...' || !trackElement.textContent || trackElement.textContent.trim() === '') {
            trackElement.textContent = "No track info available";
          }
        }
      }
    }
    
    // Fetch track info immediately
    async function fetchTrackInfo() {
      const statusUrl = window.STATUS_URL || STATUS_URL;
      if (!statusUrl) {
        console.log('[Track Info] No STATUS_URL available');
        return;
      }
      
      try {
        console.log('[Track Info] Fetching from:', statusUrl);
        // Use simple request to avoid preflight OPTIONS check
        // Simple requests don't trigger preflight if they don't have custom headers
        const response = await fetch(statusUrl + '?nocache=' + Date.now(), {
          method: 'GET',
          cache: 'no-cache',
          mode: 'cors'
        });
        
        console.log('[Track Info] Response status:', response.status, response.statusText);
        
        if (!response.ok) {
          console.log('[Track Info] Response not OK:', response.status);
          return;
        }
        
        const data = await response.json();
        console.log('[Track Info] Received data:', data);
        
        if (data.icestats && data.icestats.source) {
          const stream = Array.isArray(data.icestats.source) 
            ? data.icestats.source[0] 
            : data.icestats.source;
          
          console.log('[Track Info] Stream object:', stream);
          
          if (stream) {
            // Try multiple possible fields for track title
            let trackTitle = null;
            
            if (stream.title && stream.title.trim()) {
              trackTitle = stream.title.trim();
            } else if (stream.yp_currently_playing && stream.yp_currently_playing.trim()) {
              trackTitle = stream.yp_currently_playing.trim();
            } else if (stream.server_name) {
              trackTitle = stream.server_name;
            }
            
            console.log('[Track Info] Found track title:', trackTitle);
            
            if (trackTitle && trackTitle !== lastTrackTitle) {
              console.log('[Track Info] Updating to:', trackTitle);
              lastTrackTitle = trackTitle;
              updateTrackInfo(trackTitle);
            } else if (!trackTitle) {
              console.log('[Track Info] No track title found in stream data');
            }
          } else {
            console.log('[Track Info] No stream object found');
          }
        } else {
          console.log('[Track Info] No icestats.source found in response');
        }
      } catch (err) {
        // Log the actual error for debugging
        console.error('[Track Info] Fetch error:', err);
        console.error('[Track Info] Error details:', {
          message: err.message,
          name: err.name,
          stack: err.stack
        });
        
        // Only show error message once to avoid spam
        if (!window.trackInfoErrorLogged) {
          console.log('[Track Info] CORS or network error - check if Icecast CORS headers are configured');
          window.trackInfoErrorLogged = true;
        }
        
        // Clear "Loading track info..." if we hit an error
        const trackEl = document.querySelector('.player-track');
        if (trackEl && trackEl.textContent === 'Loading track info...') {
          trackEl.textContent = 'Track info unavailable';
        }
      }
    }
    
    let lastTrackTitle = '';
    
    // Real-time status and track info updates - check every 2 seconds
    setInterval(async () => {
      const wasLive = streamIsLive;
      await checkStreamStatus();
      
      // Update status display based on audio state
      if (audio.readyState >= 2 && !audio.paused && !audio.ended) {
        streamIsLive = true;
        if (isPlaying) {
          document.getElementById('playerStatus').innerHTML = '● LIVE';
        } else if (streamIsLive) {
          document.getElementById('playerStatus').innerHTML = '● LIVE';
        }
      } else if (audio.error || (audio.readyState === 0 && wasLive)) {
        streamIsLive = false;
        if (isPlaying) {
          stopStream();
        }
        document.getElementById('playerStatus').innerHTML = '⚫ OFFLINE';
        document.querySelector('.player-track').textContent = 'Stream offline';
      }
      
      // Always try to fetch track info when stream is live or playing
      if (streamIsLive || isPlaying || (!audio.paused && !audio.ended)) {
        fetchTrackInfo();
      }
    }, 2000);
    
    checkStreamStatus();
    
    audio.addEventListener('loadstart', function() {
      console.log('Stream loading...');
      document.getElementById('playerStatus').innerHTML = '⏳ LOADING...';
    });

    audio.addEventListener('canplay', function() {
      console.log('Stream ready to play');
      streamIsLive = true;
      const statusEl = document.getElementById('playerStatus');
      if (statusEl) statusEl.innerHTML = '● LIVE';
      // Try to fetch track info when stream is ready
      fetchTrackInfo();
    });

    audio.addEventListener('waiting', function() {
      console.log('Stream buffering...');
      if (streamIsLive) {
        document.getElementById('playerStatus').innerHTML = '⏳ BUFFERING...';
      }
    });

    audio.addEventListener('playing', function() {
      streamIsLive = true;
      document.getElementById('playerStatus').innerHTML = '● LIVE';
    });
    
    audio.addEventListener('pause', function() {
      if (!audio.ended) {
        document.getElementById('playerStatus').innerHTML = '⏸ PAUSED';
      }
    });
    
    audio.addEventListener('ended', function() {
      streamIsLive = false;
      document.getElementById('playerStatus').innerHTML = '⚫ OFFLINE';
      document.querySelector('.player-track').textContent = 'Stream ended';
    });

    audio.addEventListener('error', function(e) {
      console.error('Stream error:', e);
      streamIsLive = false;
      isPlaying = false;
      const statusEl = document.getElementById('playerStatus');
      if (statusEl) statusEl.innerHTML = '⚫ OFFLINE';
      const trackEl = document.querySelector('.player-track');
      if (trackEl) trackEl.textContent = 'Stream error';
      if (playBtn) playBtn.innerHTML = '▶';
    });
    
    function togglePlay() {
      if (isPlaying) {
        audio.pause();
        if (playBtn) playBtn.innerHTML = '▶';
        const statusEl = document.getElementById('playerStatus');
        if (statusEl) statusEl.innerHTML = '⏸ PAUSED';
        isPlaying = false;
      } else {
        const streamUrl = window.STREAM_URL || STREAM_URL;
        
        // Set audio source - HTML5 audio can play streams even with CORS issues
        if (!audio.src || audio.src !== streamUrl) {
          audio.src = streamUrl;
          console.log('Setting audio source:', streamUrl);
        }
        
        // Try to play - audio element works even with CORS errors
        const statusEl = document.getElementById('playerStatus');
        if (statusEl) statusEl.innerHTML = '⏳ LOADING...';
        
        const playPromise = audio.play();
        if (playPromise !== undefined) {
          playPromise.then(() => {
            streamIsLive = true;
            isPlaying = true;
            if (playBtn) playBtn.innerHTML = '⏸';
            if (statusEl) statusEl.innerHTML = '● LIVE';
            console.log('Playback started successfully');
            // Clear "Waiting for stream..." and fetch track info immediately
            const trackEl = document.querySelector('.player-track');
            if (trackEl && trackEl.textContent === 'Waiting for stream...') {
              trackEl.textContent = 'Loading track info...';
            }
            // Fetch track info immediately when play succeeds
            setTimeout(() => fetchTrackInfo(), 500);
          }).catch(err => {
            console.error('Play failed:', err);
            streamIsLive = false;
            isPlaying = false;
            if (statusEl) statusEl.innerHTML = '⚫ OFFLINE';
            const trackEl = document.querySelector('.player-track');
            if (trackEl) trackEl.textContent = 'Stream offline';
            
            // Try loading and playing again after a short delay
            setTimeout(() => {
              audio.load();
              audio.play().then(() => {
                playBtn.innerHTML = '⏸';
                streamIsLive = true;
                document.getElementById('playerStatus').innerHTML = '● LIVE';
                isPlaying = true;
              }).catch(err2 => {
                console.error('Retry play also failed:', err2);
                document.getElementById('playerStatus').innerHTML = '⚫ OFFLINE';
                streamIsLive = false;
                alert('Unable to connect to stream. Make sure the stream is live.');
              });
            }, 2000);
          });
        }
      }
    }
    
    function stopStream() {
      audio.pause();
      audio.load();
      streamIsLive = false;
      isPlaying = false;
      if (playBtn) playBtn.innerHTML = '▶';
      const statusEl = document.getElementById('playerStatus');
      if (statusEl) statusEl.innerHTML = '⚫ OFFLINE';
      const trackEl = document.querySelector('.player-track');
      if (trackEl) trackEl.textContent = 'Stream stopped';
    }
    
    function changeVolume(val) {
      audio.volume = val / 100;
      document.getElementById('volumeDisplay').innerHTML = val;
    }
    
    function toggleMinimize() {
      isMinimized = !isMinimized;
      const chatContainer = document.getElementById('chatContainer');
      if (isMinimized) {
        playerContent.style.display = 'none';
        musicPlayer.style.height = '30px';
        if (chatContainer) {
          chatContainer.style.display = 'none';
        }
      } else {
        playerContent.style.display = 'block';
        musicPlayer.style.height = 'auto';
        if (chatContainer) {
          chatContainer.style.display = 'flex';
        }
      }
    }
    
    // Ensure chat container is visible on page load (in case it was minimized)
    window.addEventListener('DOMContentLoaded', function() {
      const chatContainer = document.getElementById('chatContainer');
      if (chatContainer && !isMinimized) {
        chatContainer.style.display = 'flex';
      }
    });
    
    function previousTrack() {
      stopStream();
      setTimeout(() => togglePlay(), 500);
    }
    
    function nextTrack() {
      stopStream();
      setTimeout(() => togglePlay(), 500);
    }
  </script>
</body>
</html>