<!DOCTYPE html>
<html>
<head>
  <title>PaintMusic - Personal Blog</title>
  <link rel="icon" type="image/png" sizes="32x32" href="favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon.png">
  <link rel="shortcut icon" href="favicon.png">
  <link rel="apple-touch-icon" href="favicon.png">
  <link rel="stylesheet" href="style.css">
  <!-- Security Headers -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://www.gstatic.com https://www.googleapis.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https: http:; font-src 'self' data:; connect-src 'self' https://www.googleapis.com https://*.googleapis.com https://*.firebaseio.com https://*.firebase.com wss://*.firebaseio.com https://kam-budless-gael.ngrok-free.dev; media-src 'self' https://kam-budless-gael.ngrok-free.dev https://*.ngrok-free.dev http://localhost:8000 http://127.0.0.1:8000; frame-src https://www.youtube.com; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none';">
  <meta http-equiv="X-Frame-Options" content="DENY">
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
</head>
<body>
  <div class="wrapper-retro">
    <div class="header-retro">
      <div class="header-container">
        <img src="https://media1.tenor.com/m/-v0gLfm3FtEAAAAd/chuzzle-raptisoft.gif" alt="chuzzle" class="chuzzle-left">
        <div class="header-center">
          <img src="logo.png" alt="Paint's Music Page" class="header-logo">
          <div class="blink">i love music and chuzzle</div>
          <div id="userLink" class="user-status"><a href="login.html">login</a></div>
          <div class="online-counter">ONLINE: <span id="onlineCount">0</span> <img src="users-online.png" alt="users" class="users-icon"></div>
        </div>
        <img src="https://media1.tenor.com/m/-v0gLfm3FtEAAAAd/chuzzle-raptisoft.gif" alt="chuzzle" class="chuzzle-right">
      </div>
      <div class="social-links">
        <a href="https://bandcamp.com/paintyum" target="_blank">Bandcamp</a>
        <a href="https://www.last.fm/user/Paintyum" target="_blank">Last.fm</a>
      </div>
    </div>

    <div class="nav-center">
  <a href="index.html"><img src="album-reviews.png" alt="Album Reviews" class="nav-img"></a>
  <a href="interviews.html"><img src="interviews.png" alt="Interviews" class="nav-img"></a>
  <a href="blog.html"><img src="personal-blog.png" alt="Personal Blog" class="nav-img"></a>
</div>

    <div class="main-container">
      <div class="content-retro">
        <div class="blog-header">
          <img src="personal-blog.png" alt="Personal Blog" class="blog-title-logo">
          <button id="newPostBtn" onclick="showNewPostForm()" style="display: none;">New Post</button>
        </div>

        <div id="postsContainer"></div>
      </div>
    </div>

    <div id="newPostModal" class="modal">
      <div class="modal-content">
        <h2>New Post</h2>
        <form onsubmit="return false;">
          <textarea id="postContent" rows="6" placeholder="What's on your mind?" required></textarea>
          
          <div class="image-upload-container">
            <label style="color: #ffff00; display: block; margin: 15px 0 5px 0; font-weight: bold;">Upload Image (optional):</label>
            <input type="file" id="postImageInput" accept="image/*" onchange="previewPostImage(event)">
            <img id="postImagePreview" class="image-preview" style="display: none;">
          </div>
          
          <div class="modal-buttons">
            <button type="button" onclick="submitNewPost()">Post</button>
            <button type="button" onclick="hideNewPostForm()">Cancel</button>
          </div>
        </form>
      </div>
    </div>

    <div class="footer">
      &copy; paintmusic<br>
      i luv u chuzzle
    </div>
  </div>

  <script type="module" src="firebase.js"></script>
  <script type="module" src="userbar.js"></script>
  <script type="module" src="online-counter.js"></script>
  <script type="module" src="blog.js"></script>

  <!-- Radio and Chatroom Container -->
  <div class="radio-chat-wrapper" id="radioChatWrapper">
    <div class="music-player" id="musicPlayer">
    <div class="player-header" id="playerHeader">
      <div class="player-title">PAINTYUM RADIO</div>
      <div class="player-controls-top">
        <button onclick="toggleMinimize()" class="minimize-btn">_</button>
      </div>
    </div>
    
    <div class="player-content" id="playerContent">
      <!-- Video Stream Player (shown when live) -->
      <div id="videoPlayerContainer" style="display: none;">
        <div class="player-header" style="margin: -10px -10px 10px -10px; padding: 5px 10px;">
          <div class="player-title">üî¥ LIVE STREAM</div>
        </div>
        <video id="videoStream" autoplay muted playsinline style="width: 100%; max-height: 400px; background: #000;">
          Your browser does not support the video tag.
        </video>
        <div style="padding: 10px; text-align: center;">
          <button onclick="toggleVideoMute()" id="videoMuteBtn" style="padding: 5px 15px; margin: 5px;">üîä Unmute</button>
          <button onclick="stopVideoStream()" style="padding: 5px 15px; margin: 5px; background: #cc0000;">Stop</button>
        </div>
      </div>
      
      <!-- Radio Player (shown when video is offline) -->
      <div id="radioPlayerContainer">
        <div class="player-display">
          <div class="player-time" id="playerStatus">‚ö´ OFFLINE</div>
          <div class="player-station">PAINTYUM RADIO</div>
          <div class="player-track">Waiting for stream...</div>
        </div>
        
        <div class="player-buttons">
          <button onclick="previousTrack()" title="Previous">‚èÆ</button>
          <button onclick="togglePlay()" id="playBtn" title="Play">‚ñ∂</button>
          <button onclick="stopStream()" title="Stop">‚èπ</button>
          <button onclick="nextTrack()" title="Next">‚è≠</button>
        </div>
        
        <div class="volume-control">
          <span>Volume</span>
          <input type="range" min="0" max="100" value="80" id="volumeSlider" onchange="changeVolume(this.value)">
          <span id="volumeDisplay">80</span>
        </div>
      </div>
    </div>
    </div>

    <!-- Chatroom Section -->
    <div class="chat-container" id="chatContainer">
      <div class="chat-users-sidebar" id="chatUsersSidebar">
        <div class="chat-users-title">USERS</div>
        <div class="chat-users-list" id="chatUsersList"></div>
      </div>
      <div class="chat-main">
        <div class="chat-header">
          <span>CHATROOM</span>
          <div>
            <button onclick="openShopModal()" style="background: #0066cc; color: #ffff00; padding: 5px 10px; border: 2px solid #00ffff; cursor: pointer; font-size: 11px; margin-left: 10px;">SHOP</button>
            <button id="untimeoutBtn" onclick="showUntimeoutModal()" style="display: none; background: #00ff00; color: #000; padding: 5px 10px; border: none; cursor: pointer; font-size: 11px; margin-left: 10px;">Untimeout</button>
            <button id="unbanBtn" onclick="showUnbanModal()" style="display: none; background: #ffaa00; color: #000; padding: 5px 10px; border: none; cursor: pointer; font-size: 11px; margin-left: 10px;">Unban</button>
          </div>
        </div>
        <div class="chat-messages" id="chatMessages"></div>
        <div class="chat-login-message" id="loginMessage">Please log in to chat</div>
        <div class="chat-input-container" id="chatInputContainer" style="display: none;">
          <button id="gifPickerBtn" onclick="openGifPicker('chat')">GIF</button>
          <input type="text" id="chatInput" class="chat-input" placeholder="Type your message...">
          <button onclick="sendMessage()" class="chat-send-btn">Send</button>
        </div>
        <div class="xp-bar-container" id="xpBarContainer" style="display: none;">
          <div class="xp-bar-info">
            <span class="xp-level-text" id="xpLevelText">LV 1</span>
            <span class="xp-progress-text" id="xpProgressText">0 / 100 messages</span>
          </div>
          <div class="xp-bar-wrapper">
            <div class="xp-bar-fill" id="xpBarFill" style="width: 0%;"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Untimeout Modal -->
    <div id="untimeoutModal" class="chat-modal" style="display: none;">
      <div class="chat-modal-content">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
          <h3 style="margin: 0; color: #00ffff;">Untimeout Users</h3>
          <button onclick="closeUntimeoutModal()" style="background: #cc0000; color: #fff; border: none; padding: 5px 10px; cursor: pointer;">Close</button>
        </div>
        <div id="untimeoutModalContent"></div>
      </div>
    </div>

    <!-- Unban Modal -->
    <div id="unbanModal" class="chat-modal" style="display: none;">
      <div class="chat-modal-content">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
          <h3 style="margin: 0; color: #00ffff;">Banned Usernames</h3>
          <button onclick="closeUnbanModal()" style="background: #cc0000; color: #fff; border: none; padding: 5px 10px; cursor: pointer;">Close</button>
        </div>
        <div id="unbanModalContent"></div>
      </div>
    </div>
    </div>
  </div>

  <audio id="radioStream" preload="auto"></audio>

  <script type="module" src="chat.js"></script>
  <script type="module" src="shop-modal.js"></script>
  <script type="module" src="gif-picker.js"></script>

  <script>
    const audio = document.getElementById('radioStream');
    const playBtn = document.getElementById('playBtn');
    const playerContent = document.getElementById('playerContent');
    const musicPlayer = document.getElementById('musicPlayer');
    const radioChatWrapper = document.getElementById('radioChatWrapper');
    
    // Radio server configuration
    // For local network access, use your local IP (192.168.86.28)
    // For internet access via ngrok, the code will auto-detect the ngrok URL
    
    // LOCAL NETWORK ACCESS (same WiFi/network):
    const LOCAL_IP = '192.168.86.28'; // Your local network IP
    
    // Auto-detect: use localhost if on same machine, otherwise use local IP
    let RADIO_HOST = LOCAL_IP;
    let RADIO_PORT = 8000;
    let USE_HTTPS = false;
    
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || window.location.hostname === '') {
      RADIO_HOST = 'localhost';
    }
    
    // Try to auto-detect ngrok URL (if ngrok is running)
    async function detectNgrokUrl() {
      try {
        const response = await fetch('http://127.0.0.1:4040/api/tunnels');
        const data = await response.json();
        
        if (data.tunnels && data.tunnels.length > 0) {
          // Find the tunnel that forwards to localhost:8000
          const tunnel = data.tunnels.find(t => 
            t.config.addr && t.config.addr.includes('8000')
          ) || data.tunnels[0]; // Fallback to first tunnel
          
          if (tunnel && tunnel.public_url) {
            const ngrokUrl = tunnel.public_url;
            console.log('Auto-detected ngrok URL:', ngrokUrl);
            
            // Use ngrok URL
            RADIO_HOST = ngrokUrl.replace('https://', '').replace('http://', '');
            RADIO_PORT = '';
            USE_HTTPS = ngrokUrl.startsWith('https://');
            
            // Update audio source
            const PROTOCOL = USE_HTTPS ? 'https' : 'http';
            const PORT_STRING = RADIO_PORT ? `:${RADIO_PORT}` : '';
            const STREAM_URL = `${PROTOCOL}://${RADIO_HOST}${PORT_STRING}/stream`;
            const STATUS_URL = `${PROTOCOL}://${RADIO_HOST}${PORT_STRING}/status-json.xsl`;
            
            const streamUrl = window.STREAM_URL || STREAM_URL;
        audio.src = streamUrl;
            window.STREAM_URL = STREAM_URL;
            window.STATUS_URL = STATUS_URL;
            
            console.log('Radio server URL (ngrok):', STREAM_URL);
            return true;
          }
        }
      } catch (err) {
        // ngrok not running or not accessible, use local network
        console.log('ngrok not detected, using local network:', err.message);
      }
      return false;
    }
    
    // Initialize radio URLs
    let STREAM_URL, STATUS_URL;
    
    // Try to get ngrok URL from Firebase (auto-updates without code changes)
    async function getNgrokUrlFromFirebase() {
      try {
        const { getDoc, doc } = await import("https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js");
        const { db } = await import('./firebase.js');
        console.log('üîç Checking Firebase for ngrok URL...');
        const configDoc = await getDoc(doc(db, 'config', 'radio'));
        if (configDoc.exists()) {
          const data = configDoc.data();
          console.log('üìÑ Firebase config/radio document found:', data);
          if (data.ngrokUrl) {
            console.log('‚úÖ Got ngrok URL from Firebase:', data.ngrokUrl);
            return data.ngrokUrl;
          } else {
            console.warn('‚ö†Ô∏è Firebase config/radio exists but ngrokUrl field is missing');
            console.warn('üìù Available fields:', Object.keys(data));
          }
        } else {
          console.warn('‚ö†Ô∏è Firebase config/radio document does not exist');
          console.warn('üìù Create it at: Firestore ‚Üí config collection ‚Üí radio document');
          console.warn('üìù Add field: ngrokUrl (string) = "https://kam-budless-gael.ngrok-free.dev"');
        }
      } catch (err) {
        console.error('‚ùå Error getting ngrok URL from Firebase:', err);
        console.error('‚ùå Error details:', err.message, err.stack);
      }
      return null;
    }
    
    // Get video stream URL from Firebase
    async function getVideoStreamUrlFromFirebase() {
      try {
        const { getDoc, doc } = await import("https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js");
        const { db } = await import('./firebase.js');
        const configDoc = await getDoc(doc(db, 'config', 'radio'));
        if (configDoc.exists()) {
          const data = configDoc.data();
          if (data.videoStreamUrl) {
            console.log('‚úÖ Got video stream URL from Firebase:', data.videoStreamUrl);
            return data.videoStreamUrl;
          }
        }
      } catch (err) {
        console.error('‚ùå Error getting video stream URL from Firebase:', err);
      }
      return null;
    }
    
    // Check if video stream is live
    async function checkVideoStreamStatus(videoUrl) {
      if (!videoUrl) return false;
      
      try {
        // Try to fetch the HLS playlist
        const response = await fetch(videoUrl + '?nocache=' + Date.now(), {
          method: 'HEAD',
          mode: 'cors',
          cache: 'no-cache'
        });
        
        if (response.ok) {
          console.log('‚úÖ Video stream is live:', videoUrl);
          return true;
        }
      } catch (err) {
        // If HEAD fails, try using video element to check
        return new Promise((resolve) => {
          const testVideo = document.createElement('video');
          testVideo.src = videoUrl;
          testVideo.muted = true;
          
          const timeout = setTimeout(() => {
            testVideo.remove();
            resolve(false);
          }, 3000);
          
          testVideo.addEventListener('loadedmetadata', () => {
            clearTimeout(timeout);
            testVideo.remove();
            resolve(true);
          });
          
          testVideo.addEventListener('error', () => {
            clearTimeout(timeout);
            testVideo.remove();
            resolve(false);
          });
          
          testVideo.load();
        });
      }
      
      return false;
    }
    
    // Switch between video and radio
    let videoStreamUrl = null;
    let isVideoLive = false;
    let videoCheckInterval = null;
    
    async function updateStreamDisplay() {
      const videoContainer = document.getElementById('videoPlayerContainer');
      const radioContainer = document.getElementById('radioPlayerContainer');
      const videoElement = document.getElementById('videoStream');
      
      if (!videoContainer || !radioContainer || !videoElement) return;
      
      // Get video stream URL from Firebase
      if (!videoStreamUrl) {
        videoStreamUrl = await getVideoStreamUrlFromFirebase();
      }
      
      if (videoStreamUrl) {
        // Check if video stream is live
        const videoIsLive = await checkVideoStreamStatus(videoStreamUrl);
        
        if (videoIsLive && !isVideoLive) {
          // Video just went live - switch to video
          console.log('üé• Switching to video stream');
          isVideoLive = true;
          videoContainer.style.display = 'block';
          radioContainer.style.display = 'none';
          
          // Set video source
          if (videoElement.src !== videoStreamUrl) {
            videoElement.src = videoStreamUrl;
            videoElement.load();
            videoElement.play().catch(err => {
              console.error('Error playing video:', err);
            });
          }
          
          // Pause radio if playing
          if (isPlaying) {
            audio.pause();
            isPlaying = false;
            const playBtn = document.getElementById('playBtn');
            if (playBtn) playBtn.innerHTML = '‚ñ∂';
          }
        } else if (!videoIsLive && isVideoLive) {
          // Video just went offline - switch back to radio
          console.log('üìª Switching back to radio');
          isVideoLive = false;
          videoContainer.style.display = 'none';
          radioContainer.style.display = 'block';
          
          // Stop video
          videoElement.pause();
          videoElement.src = '';
        }
      } else {
        // No video stream URL configured - show radio
        if (isVideoLive) {
          isVideoLive = false;
          videoContainer.style.display = 'none';
          radioContainer.style.display = 'block';
          videoElement.pause();
          videoElement.src = '';
        }
      }
    }
    
    // Video control functions
    let isVideoMuted = true;
    function toggleVideoMute() {
      const videoElement = document.getElementById('videoStream');
      const muteBtn = document.getElementById('videoMuteBtn');
      if (videoElement) {
        isVideoMuted = !isVideoMuted;
        videoElement.muted = isVideoMuted;
        if (muteBtn) {
          muteBtn.textContent = isVideoMuted ? 'üîä Unmute' : 'üîá Mute';
        }
      }
    }
    
    function stopVideoStream() {
      const videoElement = document.getElementById('videoStream');
      if (videoElement) {
        videoElement.pause();
        videoElement.src = '';
      }
      isVideoLive = false;
      updateStreamDisplay();
    }
    
    // If site is HTTPS, we MUST use HTTPS stream (ngrok)
    const isHttpsSite = window.location.protocol === 'https:';
    
    // Function to set stream URL and update audio
    function setStreamUrl(url) {
      RADIO_HOST = url.replace('https://', '').replace('http://', '');
      RADIO_PORT = '';
      USE_HTTPS = url.startsWith('https://');
      STREAM_URL = `${USE_HTTPS ? 'https' : 'http'}://${RADIO_HOST}/stream`;
      STATUS_URL = `${USE_HTTPS ? 'https' : 'http'}://${RADIO_HOST}/status-json.xsl`;
      
      // Update audio source
      audio.src = STREAM_URL;
      window.STREAM_URL = STREAM_URL;
      window.STATUS_URL = STATUS_URL;
      
      console.log('üéµ Stream URL set to:', STREAM_URL);
      console.log('üéµ Audio src set to:', audio.src);
      
      // Reload audio to use new source
      audio.load();
    }
    
    // Try to detect ngrok first, then fall back to Firebase, then local network
    detectNgrokUrl().then(async (ngrokFound) => {
      console.log('üîç ngrok detection result:', ngrokFound);
      
      if (!ngrokFound) {
        // Try to get from Firebase
        console.log('üîç ngrok not auto-detected, checking Firebase...');
        const firebaseNgrokUrl = await getNgrokUrlFromFirebase();
        
        if (firebaseNgrokUrl) {
          // Use ngrok URL from Firebase
          setStreamUrl(firebaseNgrokUrl);
          console.log('‚úÖ Using ngrok URL from Firebase:', STREAM_URL);
        } else if (isHttpsSite) {
          // HTTPS site needs HTTPS stream - warn user
          console.error('‚ùå ERROR: HTTPS site requires ngrok URL. Please set it in Firebase config/radio document.');
          console.error('üìù To fix: Go to Firebase Console ‚Üí Firestore ‚Üí Create document at: config/radio');
          console.error('üìù Add field: ngrokUrl = "https://kam-budless-gael.ngrok-free.dev"');
          console.error('üìù Current site protocol:', window.location.protocol);
          console.error('üìù Current site URL:', window.location.href);
          
          // Show error message to user
          const statusEl = document.getElementById('playerStatus');
          if (statusEl) {
            statusEl.innerHTML = '‚ö´ CONFIG ERROR';
          }
          const trackEl = document.querySelector('.player-track');
          if (trackEl) {
            trackEl.textContent = 'Stream URL not configured - check console';
          }
        } else {
          // Use local network (only works on HTTP sites or localhost)
          const PROTOCOL = USE_HTTPS ? 'https' : 'http';
          const PORT_STRING = RADIO_PORT ? `:${RADIO_PORT}` : '';
          STREAM_URL = `${PROTOCOL}://${RADIO_HOST}${PORT_STRING}/stream`;
          STATUS_URL = `${PROTOCOL}://${RADIO_HOST}${PORT_STRING}/status-json.xsl`;
          audio.src = STREAM_URL;
          window.STREAM_URL = STREAM_URL;
          window.STATUS_URL = STATUS_URL;
          console.log('üìª Radio server URL (local network):', STREAM_URL);
        }
      } else {
        console.log('‚úÖ ngrok auto-detected and configured');
      }
    });
    
    // Also try Firebase immediately (in case ngrok detection takes time)
    if (isHttpsSite) {
      getNgrokUrlFromFirebase().then((firebaseNgrokUrl) => {
        if (firebaseNgrokUrl && (!window.STREAM_URL || !window.STREAM_URL.includes('ngrok'))) {
          console.log('üîÑ Updating stream URL from Firebase (secondary check)');
          setStreamUrl(firebaseNgrokUrl);
        }
      });
    }
    
    // Set initial URLs (will be updated if ngrok is found)
    const PROTOCOL = USE_HTTPS ? 'https' : 'http';
    const PORT_STRING = RADIO_PORT ? `:${RADIO_PORT}` : '';
    STREAM_URL = `${PROTOCOL}://${RADIO_HOST}${PORT_STRING}/stream`;
    STATUS_URL = `${PROTOCOL}://${RADIO_HOST}${PORT_STRING}/status-json.xsl`;
    window.STREAM_URL = STREAM_URL;
    window.STATUS_URL = STATUS_URL;
    
    let isPlaying = false;
    let isMinimized = false;
    let streamIsLive = false;
    
    audio.src = STREAM_URL;
    audio.volume = 0.8;
    
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    let xOffset = 0;
    let yOffset = 0;

    const playerHeader = document.getElementById('playerHeader');
    const chatContainer = document.getElementById('chatContainer');

    // Ensure chat container is visible on page load
    if (chatContainer) {
      chatContainer.style.display = 'flex';
    }

    // Set default centered position if no saved position exists
    const savedLeft = localStorage.getItem('radioChatWrapperLeft');
    const savedTop = localStorage.getItem('radioChatWrapperTop');
    if (!savedLeft || !savedTop) {
      // Center the radio vertically and horizontally on page load
      const centerX = window.innerWidth / 2 - 250; // 250 is half of 500px width
      const centerY = window.innerHeight / 2 - 200; // Approximate center (adjust as needed)
      radioChatWrapper.style.setProperty('left', centerX + 'px', 'important');
      radioChatWrapper.style.setProperty('top', centerY + 'px', 'important');
      radioChatWrapper.style.setProperty('position', 'absolute', 'important');
    } else {
      // Load saved position
      radioChatWrapper.style.setProperty('left', savedLeft, 'important');
      radioChatWrapper.style.setProperty('top', savedTop, 'important');
      radioChatWrapper.style.setProperty('position', 'absolute', 'important');
    }

    // Make both header and chat container draggable
    playerHeader.addEventListener('mousedown', dragStart);
    if (chatContainer) {
      chatContainer.addEventListener('mousedown', dragStart);
    }
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', dragEnd);

    function dragStart(e) {
      // Don't drag if clicking buttons or input fields
      if (e.target.classList.contains('minimize-btn') || 
          e.target.tagName === 'BUTTON' || 
          e.target.tagName === 'INPUT' ||
          e.target.closest('button') ||
          e.target.closest('input')) {
        return;
      }
      
      // Get current position relative to document
      const rect = radioChatWrapper.getBoundingClientRect();
      const scrollX = window.scrollX || window.pageXOffset;
      const scrollY = window.scrollY || window.pageYOffset;
      const currentLeft = rect.left + scrollX;
      const currentTop = rect.top + scrollY;
      initialX = e.clientX - currentLeft;
      initialY = e.clientY - currentTop;
      isDragging = true;
      
      if (e.target.closest('#playerHeader')) {
        playerHeader.style.cursor = 'grabbing';
      }
      if (chatContainer) {
        chatContainer.style.cursor = 'grabbing';
      }
    }

    function drag(e) {
      if (isDragging) {
        e.preventDefault();
        
        // Calculate new position relative to document
        currentX = e.clientX - initialX + window.scrollX;
        currentY = e.clientY - initialY + window.scrollY;
        
        // Update position - use absolute positioning relative to document
        radioChatWrapper.style.setProperty('left', currentX + 'px', 'important');
        radioChatWrapper.style.setProperty('top', currentY + 'px', 'important');
        radioChatWrapper.style.setProperty('position', 'absolute', 'important');
      }
    }

    function dragEnd(e) {
      if (isDragging) {
        // Store final position relative to document
        const finalX = e.clientX - initialX + window.scrollX;
        const finalY = e.clientY - initialY + window.scrollY;
        radioChatWrapper.style.setProperty('left', finalX + 'px', 'important');
        radioChatWrapper.style.setProperty('top', finalY + 'px', 'important');
        // Save position to localStorage
        localStorage.setItem('radioChatWrapperLeft', finalX + 'px');
        localStorage.setItem('radioChatWrapperTop', finalY + 'px');
      }
      isDragging = false;
      playerHeader.style.cursor = 'move';
      if (chatContainer) {
        chatContainer.style.cursor = 'default';
      }
    }
    
    async function checkStreamStatus() {
      // CORS prevents fetch requests, so we rely entirely on audio element events
      // HTML5 audio can play streams even with CORS errors
      const streamUrl = window.STREAM_URL || STREAM_URL;
      
      // Ensure audio source is set
      if (streamUrl && (!audio.src || audio.src !== streamUrl)) {
        audio.src = streamUrl;
        console.log('Audio source set to:', streamUrl);
      }
      
      // Check audio element state to determine if stream is live
      // If audio is playing or ready, stream is likely live
      if (!audio.paused && !audio.ended && audio.readyState >= 2) {
        if (!streamIsLive) {
          streamIsLive = true;
          document.getElementById('playerStatus').innerHTML = '‚óè LIVE';
          console.log('Stream detected as LIVE (audio playing)');
        }
        return true;
      }
      
      return streamIsLive;
    }
    
    function updateTrackInfo(title) {
      const trackElement = document.querySelector('.player-track');
      if (trackElement) {
        if (title && title.trim() && title !== 'Live Radio Stream' && title !== 'unknown' && title.trim() !== '') {
          trackElement.textContent = title.trim();
        } else {
          // Don't change to "No track info available" if we already have a song name
          if (trackElement.textContent === 'Waiting for stream...' || !trackElement.textContent || trackElement.textContent.trim() === '') {
            trackElement.textContent = "No track info available";
          }
        }
      }
    }
    
    // Fetch track info immediately
    async function fetchTrackInfo() {
      const statusUrl = window.STATUS_URL || STATUS_URL;
      if (!statusUrl) {
        console.log('[Track Info] No STATUS_URL available');
        return;
      }
      
      try {
        console.log('[Track Info] Fetching from:', statusUrl);
        // Use simple request to avoid preflight OPTIONS check
        // Simple requests don't trigger preflight if they don't have custom headers
        const response = await fetch(statusUrl + '?nocache=' + Date.now(), {
          method: 'GET',
          cache: 'no-cache',
          mode: 'cors'
        });
        
        console.log('[Track Info] Response status:', response.status, response.statusText);
        
        if (!response.ok) {
          console.log('[Track Info] Response not OK:', response.status);
          return;
        }
        
        const data = await response.json();
        console.log('[Track Info] Received data:', data);
        
        if (data.icestats && data.icestats.source) {
          const stream = Array.isArray(data.icestats.source) 
            ? data.icestats.source[0] 
            : data.icestats.source;
          
          console.log('[Track Info] Stream object:', stream);
          
          if (stream) {
            // Try multiple possible fields for track title
            let trackTitle = null;
            
            if (stream.title && stream.title.trim()) {
              trackTitle = stream.title.trim();
            } else if (stream.yp_currently_playing && stream.yp_currently_playing.trim()) {
              trackTitle = stream.yp_currently_playing.trim();
            } else if (stream.server_name) {
              trackTitle = stream.server_name;
            }
            
            console.log('[Track Info] Found track title:', trackTitle);
            
            if (trackTitle && trackTitle !== lastTrackTitle) {
              console.log('[Track Info] Updating to:', trackTitle);
              lastTrackTitle = trackTitle;
              updateTrackInfo(trackTitle);
            } else if (!trackTitle) {
              console.log('[Track Info] No track title found in stream data');
            }
          } else {
            console.log('[Track Info] No stream object found');
          }
        } else {
          console.log('[Track Info] No icestats.source found in response');
        }
      } catch (err) {
        // Log the actual error for debugging
        console.error('[Track Info] Fetch error:', err);
        console.error('[Track Info] Error details:', {
          message: err.message,
          name: err.name,
          stack: err.stack
        });
        
        // Only show error message once to avoid spam
        if (!window.trackInfoErrorLogged) {
          console.log('[Track Info] CORS or network error - check if Icecast CORS headers are configured');
          window.trackInfoErrorLogged = true;
        }
        
        // Clear "Loading track info..." if we hit an error
        const trackEl = document.querySelector('.player-track');
        if (trackEl && trackEl.textContent === 'Loading track info...') {
          trackEl.textContent = 'Track info unavailable';
        }
      }
    }
    
    let lastTrackTitle = '';
    
    // Real-time status and track info updates - check every 2 seconds
    setInterval(async () => {
      const wasLive = streamIsLive;
      await checkStreamStatus();
      
      // Update status display based on audio state
      if (audio.readyState >= 2 && !audio.paused && !audio.ended) {
        streamIsLive = true;
        if (isPlaying) {
          document.getElementById('playerStatus').innerHTML = '‚óè LIVE';
        } else if (streamIsLive) {
          document.getElementById('playerStatus').innerHTML = '‚óè LIVE';
        }
      } else if (audio.error || (audio.readyState === 0 && wasLive)) {
        streamIsLive = false;
        if (isPlaying) {
          stopStream();
        }
        document.getElementById('playerStatus').innerHTML = '‚ö´ OFFLINE';
        document.querySelector('.player-track').textContent = 'Stream offline';
      }
      
      // Always try to fetch track info when stream is live or playing
      if (streamIsLive || isPlaying || (!audio.paused && !audio.ended)) {
        fetchTrackInfo();
      }
    }, 2000);
    
    // Start checking video stream status every 5 seconds
    if (!videoCheckInterval) {
      videoCheckInterval = setInterval(updateStreamDisplay, 5000);
      // Check immediately
      updateStreamDisplay();
    }
    
    checkStreamStatus();
    
    audio.addEventListener('loadstart', function() {
      console.log('Stream loading...');
      document.getElementById('playerStatus').innerHTML = '‚è≥ LOADING...';
    });

    audio.addEventListener('canplay', function() {
      console.log('Stream ready to play');
      streamIsLive = true;
      const statusEl = document.getElementById('playerStatus');
      if (statusEl) statusEl.innerHTML = '‚óè LIVE';
      // Try to fetch track info when stream is ready
      fetchTrackInfo();
    });

    audio.addEventListener('waiting', function() {
      console.log('Stream buffering...');
      if (streamIsLive) {
        document.getElementById('playerStatus').innerHTML = '‚è≥ BUFFERING...';
      }
    });

    audio.addEventListener('playing', function() {
      streamIsLive = true;
      document.getElementById('playerStatus').innerHTML = '‚óè LIVE';
    });
    
    audio.addEventListener('pause', function() {
      if (!audio.ended) {
        document.getElementById('playerStatus').innerHTML = '‚è∏ PAUSED';
      }
    });
    
    audio.addEventListener('ended', function() {
      streamIsLive = false;
      document.getElementById('playerStatus').innerHTML = '‚ö´ OFFLINE';
      document.querySelector('.player-track').textContent = 'Stream ended';
    });

    audio.addEventListener('error', function(e) {
      console.error('‚ùå Stream error:', e);
      console.error('‚ùå Audio error code:', audio.error ? audio.error.code : 'unknown');
      console.error('‚ùå Audio error message:', audio.error ? audio.error.message : 'unknown');
      console.error('‚ùå Current audio src:', audio.src);
      console.error('‚ùå Expected STREAM_URL:', window.STREAM_URL || STREAM_URL);
      
      streamIsLive = false;
      isPlaying = false;
      const statusEl = document.getElementById('playerStatus');
      if (statusEl) statusEl.innerHTML = '‚ö´ OFFLINE';
      const trackEl = document.querySelector('.player-track');
      if (trackEl) {
        if (audio.error) {
          const errorMsg = audio.error.code === 4 ? 'Stream URL not found - check ngrok/Firebase config' : 
                          audio.error.code === 2 ? 'Network error - check stream is running' :
                          'Stream error - check console';
          trackEl.textContent = errorMsg;
        } else {
          trackEl.textContent = 'Stream error - check console';
        }
      }
      if (playBtn) playBtn.innerHTML = '‚ñ∂';
    });
    
    // Function to refresh stream URL from Firebase
    window.refreshStreamUrl = async function() {
      console.log('üîÑ Manually refreshing stream URL from Firebase...');
      const firebaseNgrokUrl = await getNgrokUrlFromFirebase();
      if (firebaseNgrokUrl) {
        setStreamUrl(firebaseNgrokUrl);
        console.log('‚úÖ Stream URL refreshed:', STREAM_URL);
        return true;
      } else {
        console.error('‚ùå Could not refresh stream URL - Firebase config not found');
        return false;
      }
    };
    
    function togglePlay() {
      if (isPlaying) {
        audio.pause();
        if (playBtn) playBtn.innerHTML = '‚ñ∂';
        const statusEl = document.getElementById('playerStatus');
        if (statusEl) statusEl.innerHTML = '‚è∏ PAUSED';
        isPlaying = false;
      } else {
        const streamUrl = window.STREAM_URL || STREAM_URL;
        
        console.log('‚ñ∂ Play button clicked');
        console.log('üéµ Current audio.src:', audio.src);
        console.log('üéµ Expected STREAM_URL:', streamUrl);
        
        // Set audio source - HTML5 audio can play streams even with CORS issues
        if (!audio.src || audio.src !== streamUrl) {
          console.log('üîÑ Updating audio source to:', streamUrl);
          audio.src = streamUrl;
          audio.load(); // Reload to use new source
        }
        
        // Try to play - audio element works even with CORS errors
        const statusEl = document.getElementById('playerStatus');
        if (statusEl) statusEl.innerHTML = '‚è≥ LOADING...';
        
        const playPromise = audio.play();
        if (playPromise !== undefined) {
          playPromise.then(() => {
            streamIsLive = true;
            isPlaying = true;
            if (playBtn) playBtn.innerHTML = '‚è∏';
            if (statusEl) statusEl.innerHTML = '‚óè LIVE';
            console.log('‚úÖ Playback started successfully');
            // Clear "Waiting for stream..." and fetch track info immediately
            const trackEl = document.querySelector('.player-track');
            if (trackEl && trackEl.textContent === 'Waiting for stream...') {
              trackEl.textContent = 'Loading track info...';
            }
            // Fetch track info immediately when play succeeds
            setTimeout(() => fetchTrackInfo(), 500);
          }).catch(err => {
            console.error('‚ùå Play failed:', err);
            console.error('‚ùå Error code:', audio.error ? audio.error.code : 'unknown');
            console.error('‚ùå Error message:', audio.error ? audio.error.message : 'unknown');
            streamIsLive = false;
            isPlaying = false;
            if (statusEl) statusEl.innerHTML = '‚ö´ OFFLINE';
            const trackEl = document.querySelector('.player-track');
            if (trackEl) {
              trackEl.textContent = 'Stream offline - check console for details';
            }
            
            // Try refreshing URL from Firebase and retry
            console.log('üîÑ Attempting to refresh stream URL and retry...');
            window.refreshStreamUrl().then((refreshed) => {
              if (refreshed) {
                setTimeout(() => {
                  audio.load();
                  audio.play().then(() => {
                    playBtn.innerHTML = '‚è∏';
                    streamIsLive = true;
                    document.getElementById('playerStatus').innerHTML = '‚óè LIVE';
                    isPlaying = true;
                    console.log('‚úÖ Retry after refresh succeeded');
                  }).catch(err2 => {
                    console.error('‚ùå Retry play also failed:', err2);
                    document.getElementById('playerStatus').innerHTML = '‚ö´ OFFLINE';
                    streamIsLive = false;
                    alert('Unable to connect to stream. Check:\n1. ngrok is running\n2. Firebase config/radio has ngrokUrl\n3. Stream server is running on port 8000');
                  });
                }, 1000);
              } else {
                alert('Unable to connect to stream. Check:\n1. Firebase config/radio document exists\n2. ngrokUrl field is set to: https://kam-budless-gael.ngrok-free.dev\n3. Stream server is running');
              }
            });
          });
        }
      }
    }
    
    function stopStream() {
      audio.pause();
      audio.load();
      streamIsLive = false;
      isPlaying = false;
      if (playBtn) playBtn.innerHTML = '‚ñ∂';
      const statusEl = document.getElementById('playerStatus');
      if (statusEl) statusEl.innerHTML = '‚ö´ OFFLINE';
      const trackEl = document.querySelector('.player-track');
      if (trackEl) trackEl.textContent = 'Stream stopped';
    }
    
    function changeVolume(val) {
      audio.volume = val / 100;
      document.getElementById('volumeDisplay').innerHTML = val;
    }
    
    function toggleMinimize() {
      isMinimized = !isMinimized;
      const chatContainer = document.getElementById('chatContainer');
      if (isMinimized) {
        playerContent.style.display = 'none';
        musicPlayer.style.height = '30px';
        if (chatContainer) {
          chatContainer.style.display = 'none';
        }
      } else {
        playerContent.style.display = 'block';
        musicPlayer.style.height = 'auto';
        if (chatContainer) {
          chatContainer.style.display = 'flex';
        }
      }
    }
    
    // Ensure chat container is visible on page load (in case it was minimized)
    window.addEventListener('DOMContentLoaded', function() {
      const chatContainer = document.getElementById('chatContainer');
      if (chatContainer && !isMinimized) {
        chatContainer.style.display = 'flex';
      }
    });
    
    function previousTrack() {
      stopStream();
      setTimeout(() => togglePlay(), 500);
    }
    
    function nextTrack() {
      stopStream();
      setTimeout(() => togglePlay(), 500);
    }
  </script>
</body>
</html>