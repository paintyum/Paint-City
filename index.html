<!DOCTYPE html>
<html>
<head>
  <title>PaintMusic</title>
  <link rel="icon" type="image/png" sizes="32x32" href="favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon.png">
  <link rel="shortcut icon" href="favicon.png">
  <link rel="apple-touch-icon" href="favicon.png">
  <link rel="stylesheet" href="style.css">
  <script src="router.js"></script>
  <!-- Security Headers -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://www.gstatic.com https://www.googleapis.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https: http:; font-src 'self' data:; connect-src 'self' https://www.googleapis.com https://*.googleapis.com https://*.firebaseio.com https://*.firebase.com wss://*.firebaseio.com https://kam-budless-gael.ngrok-free.dev; media-src 'self' https://kam-budless-gael.ngrok-free.dev https://*.ngrok-free.dev http://localhost:8000 http://127.0.0.1:8000; frame-src https://www.youtube.com; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none';">
  <meta http-equiv="X-Frame-Options" content="DENY">
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
</head>
<body>
  <div class="wrapper-retro">
    <div class="header-retro">
      <div class="header-container">
        <img src="https://media1.tenor.com/m/-v0gLfm3FtEAAAAd/chuzzle-raptisoft.gif" alt="chuzzle" class="chuzzle-left">
        <div class="header-center">
          <img src="logo.png" alt="Paint's Music Page" class="header-logo">
          <div class="blink">i love music and chuzzle</div>
          <div id="userLink" class="user-status"><a href="/login">login</a></div>
          <div class="online-counter">ONLINE: <span id="onlineCount">0</span> <img src="users-online.png" alt="users" class="users-icon"></div>
        </div>
        <img src="https://media1.tenor.com/m/-v0gLfm3FtEAAAAd/chuzzle-raptisoft.gif" alt="chuzzle" class="chuzzle-right">
      </div>
    </div>

    <div class="live-banner-container">
      <div class="live-banner-wrapper" id="liveBannerWrapper">
        <div class="live-banner-scroll" id="liveBannerText">GOING LIVE AT 3PM EST</div>
        <div class="live-banner-scroll" id="liveBannerText2">GOING LIVE AT 3PM EST</div>
        <div class="live-banner-scroll" id="liveBannerText3">GOING LIVE AT 3PM EST</div>
        <div class="live-banner-scroll" id="liveBannerText4">GOING LIVE AT 3PM EST</div>
        <div class="live-banner-scroll" id="liveBannerText5">GOING LIVE AT 3PM EST</div>
        <div class="live-banner-scroll" id="liveBannerText6">GOING LIVE AT 3PM EST</div>
      </div>
      <button id="editLiveBannerBtn" onclick="editLiveBanner()" style="display: none; position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: #0066cc; color: #ffff00; border: 1px solid #00ffff; padding: 2px 8px; font-size: 10px; cursor: pointer; z-index: 10;">Edit</button>
    </div>

    <div class="nav-center">
  <a href="/album-reviews"><img src="album-reviews.png" alt="Album Reviews" class="nav-img"></a>
  <a href="/interviews"><img src="interviews.png" alt="Interviews" class="nav-img"></a>
  <a href="/personal-blog"><img src="personal-blog.png" alt="Personal Blog" class="nav-img"></a>
</div>

    <div class="main-container">
      <div class="content-retro">
        <div class="reviews-header">
          <img src="album-reviews.png" alt="Album Reviews" class="reviews-title-logo">
          <div class="review-controls">
            <input type="text" id="genreFilter" list="genreList" placeholder="Search genre..." oninput="filterReviews()">
            <datalist id="genreList">
              <option value="all">All Genres</option>
            </datalist>
            <input type="text" id="albumArtistSearch" placeholder="Search album or artist..." oninput="filterReviews()">
            <button id="newReviewBtn" onclick="showNewReviewForm()" style="display: none;">New Review</button>
          </div>
        </div>

        <div id="reviewsContainer"></div>
      </div>
    </div>

    <div id="newReviewModal" class="modal">
      <div class="modal-content">
        <h2 id="modalTitle">New Album Review</h2>
        <form id="newReviewForm" onsubmit="return false;">
          <input type="hidden" id="editReviewId" value="">
          
          <label>Album Title:</label>
          <input type="text" id="albumTitle" required>
          
          <label>Artist:</label>
          <input type="text" id="artist" required>
          
          <label>Genres (separate with commas):</label>
<input type="text" id="genreInput" required placeholder="e.g., Black Metal, Shoegaze, Post-Rock">
          
          <label>Album Cover:</label>
          <input type="file" id="albumCoverInput" accept="image/*" onchange="previewAlbumCover(event)">
          <img id="albumCoverPreview" style="display: none; max-width: 200px; margin: 10px 0;">
          
          <label>Rating:</label>
          <div class="rating-options">
            <label><input type="radio" name="rating" id="mustListen"> Must Listen (Red Glow)</label>
            <label><input type="radio" name="rating" id="highlyEnjoyed"> Highly Enjoyed (Blue Glow)</label>
            <label><input type="radio" name="rating" id="enjoyed"> Enjoyed (Yellow Glow)</label>
            <label><input type="radio" name="rating" id="notGood"> Not Good (Gray Glow)</label>
          </div>
          
          <label>Review:</label>
          <textarea id="reviewText" rows="6" required></textarea>
          
          <div class="modal-buttons">
            <button type="button" onclick="submitNewReview()">Save Review</button>
            <button type="button" onclick="hideNewReviewForm()">Cancel</button>
          </div>
        </form>
      </div>
    </div>

    <div class="footer">
      &copy; paintmusic<br>
      i luv u chuzzle
    </div>
  </div>

  <script type="module" src="firebase.js"></script>
  <script type="module" src="comments.js"></script>
  <script type="module" src="userbar.js"></script>
  <script type="module" src="online-counter.js"></script>
  <script type="module" src="admin-review.js"></script>
  <script type="module" src="gif-picker.js"></script>
  <script type="module" src="shop-modal.js"></script>
  
  <!-- User Star Rating Script for Comments -->
  <script>
    window.setUserRating = function(reviewId, rating) {
      const ratingInput = document.getElementById('userRating-' + reviewId);
      if (ratingInput) {
        ratingInput.value = rating;
      }
      for (let i = 1; i <= 5; i++) {
        const star = document.getElementById('userStar' + i + '-' + reviewId);
        if (star) {
          star.textContent = i <= rating ? '★' : '☆';
          star.style.color = i <= rating ? '#ffff00' : '#666';
        }
      }
    };
  </script>

  <!-- Live Banner Script -->
  <script type="module">
    import { auth, db } from './firebase.js';
    import { onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
    import { getDoc, doc, setDoc, onSnapshot } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

    // Function to update all banner text instances
    function updateBannerTextInstances(text) {
      const bannerText = document.getElementById('liveBannerText');
      const bannerText2 = document.getElementById('liveBannerText2');
      const bannerText3 = document.getElementById('liveBannerText3');
      const bannerText4 = document.getElementById('liveBannerText4');
      const bannerText5 = document.getElementById('liveBannerText5');
      const bannerText6 = document.getElementById('liveBannerText6');
      
      if (bannerText) bannerText.textContent = text;
      if (bannerText2) bannerText2.textContent = text;
      if (bannerText3) bannerText3.textContent = text;
      if (bannerText4) bannerText4.textContent = text;
      if (bannerText5) bannerText5.textContent = text;
      if (bannerText6) bannerText6.textContent = text;
    }

    // Load live banner text and update all instances for seamless loop
    async function loadLiveBanner() {
      try {
        const bannerDoc = await getDoc(doc(db, 'config', 'liveBanner'));
        const text = bannerDoc.exists() && bannerDoc.data().text ? bannerDoc.data().text : 'GOING LIVE AT 3PM EST';
        updateBannerTextInstances(text);
      } catch (err) {
        console.log('Could not load live banner:', err.message);
      }
    }

    // Real-time listener for banner text updates (no page refresh needed)
    onSnapshot(doc(db, 'config', 'liveBanner'), (bannerDoc) => {
      if (bannerDoc.exists() && bannerDoc.data().text) {
        updateBannerTextInstances(bannerDoc.data().text);
      }
    });

    // Show edit button for admins only
    onAuthStateChanged(auth, async (user) => {
      if (user) {
        try {
          const userDoc = await getDoc(doc(db, 'users', user.uid));
          if (userDoc.exists() && userDoc.data().isAdmin) {
            const editBtn = document.getElementById('editLiveBannerBtn');
            if (editBtn) {
              editBtn.style.display = 'block';
            }
          }
        } catch (err) {
          console.log('Could not check admin status:', err.message);
        }
      }
    });

    // Edit live banner (admin only)
    window.editLiveBanner = async function() {
      const user = auth.currentUser;
      if (!user) {
        alert('Please log in first');
        return;
      }

      try {
        const userDoc = await getDoc(doc(db, 'users', user.uid));
        if (!userDoc.exists() || !userDoc.data().isAdmin) {
          alert('Admin only');
          return;
        }

        const currentText = document.getElementById('liveBannerText').textContent;
        const newText = prompt('Enter new live banner text:', currentText);
        if (newText !== null && newText.trim()) {
          await setDoc(doc(db, 'config', 'liveBanner'), {
            text: newText.trim(),
            updatedAt: Date.now(),
            updatedBy: userDoc.data().username
          });
          // Text will update automatically via onSnapshot listener
          alert('Live banner updated!');
        }
      } catch (err) {
        alert('Error updating live banner: ' + err.message);
        console.error(err);
      }
    };

    // Load banner on page load
    loadLiveBanner();
  </script>

  <!-- Radio and Chatroom Container -->
  <div class="radio-chat-wrapper" id="radioChatWrapper">
    <div class="music-player" id="musicPlayer">
      <div class="player-header" id="playerHeader">
        <div class="player-title">PAINTYUM RADIO</div>
        <div class="player-controls-top">
          <button onclick="toggleMinimize()" class="minimize-btn">_</button>
        </div>
      </div>
      
      <div class="player-content" id="playerContent">
        <div class="player-display">
          <div class="player-time" id="playerStatus">⚫ OFFLINE</div>
          <div class="player-station">PAINTYUM RADIO</div>
          <div class="player-track">Waiting for stream...</div>
        </div>
        
        <div class="player-buttons">
          <button onclick="previousTrack()" title="Previous">⏮</button>
          <button onclick="togglePlay()" id="playBtn" title="Play">▶</button>
          <button onclick="stopStream()" title="Stop">⏹</button>
          <button onclick="nextTrack()" title="Next">⏭</button>
        </div>
        
        <div class="volume-control">
          <span>Volume</span>
          <input type="range" min="0" max="100" value="80" id="volumeSlider" onchange="changeVolume(this.value)">
          <span id="volumeDisplay">80</span>
        </div>
      </div>
    </div>

    <!-- Chatroom Section -->
    <div class="chat-container" id="chatContainer">
      <div class="chat-users-sidebar" id="chatUsersSidebar">
        <div class="chat-users-title">USERS</div>
        <div class="chat-users-list" id="chatUsersList"></div>
      </div>
      <div class="chat-main">
        <div class="chat-header">
          <span>CHATROOM</span>
          <div>
            <button onclick="openShopModal()" style="background: #0066cc; color: #ffff00; padding: 5px 10px; border: 2px solid #00ffff; cursor: pointer; font-size: 11px; margin-left: 10px;">SHOP</button>
            <button id="untimeoutBtn" onclick="showUntimeoutModal()" style="display: none; background: #00ff00; color: #000; padding: 5px 10px; border: none; cursor: pointer; font-size: 11px; margin-left: 10px;">Untimeout</button>
            <button id="unbanBtn" onclick="showUnbanModal()" style="display: none; background: #ffaa00; color: #000; padding: 5px 10px; border: none; cursor: pointer; font-size: 11px; margin-left: 10px;">Unban</button>
          </div>
        </div>
        <div class="chat-messages" id="chatMessages"></div>
        <div class="chat-login-message" id="loginMessage">Please log in to chat</div>
        <div class="chat-input-container" id="chatInputContainer" style="display: none;">
          <button id="gifPickerBtn" onclick="openGifPicker('chat')">GIF</button>
          <input type="text" id="chatInput" class="chat-input" placeholder="Type your message...">
          <button onclick="sendMessage()" class="chat-send-btn">Send</button>
        </div>
        <div class="xp-bar-container" id="xpBarContainer" style="display: none;">
          <div class="xp-bar-info">
            <span class="xp-level-text" id="xpLevelText">LV 1</span>
            <span class="xp-progress-text" id="xpProgressText">0 / 100 messages</span>
          </div>
          <div class="xp-bar-wrapper">
            <div class="xp-bar-fill" id="xpBarFill" style="width: 0%;"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Untimeout Modal -->
    <div id="untimeoutModal" class="chat-modal" style="display: none;">
      <div class="chat-modal-content">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
          <h3 style="margin: 0; color: #00ffff;">Untimeout Users</h3>
          <button onclick="closeUntimeoutModal()" style="background: #cc0000; color: #fff; border: none; padding: 5px 10px; cursor: pointer;">Close</button>
        </div>
        <div id="untimeoutModalContent"></div>
      </div>
    </div>

    <!-- Unban Modal -->
    <div id="unbanModal" class="chat-modal" style="display: none;">
      <div class="chat-modal-content">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
          <h3 style="margin: 0; color: #00ffff;">Banned Usernames</h3>
          <button onclick="closeUnbanModal()" style="background: #cc0000; color: #fff; border: none; padding: 5px 10px; cursor: pointer;">Close</button>
        </div>
        <div id="unbanModalContent"></div>
      </div>
    </div>
    </div>
  </div>

  <audio id="radioStream" preload="auto"></audio>

  <script type="module" src="chat.js"></script>
  <script type="module" src="gif-picker.js"></script>

  <script>
    const audio = document.getElementById('radioStream');
    const playBtn = document.getElementById('playBtn');
    const playerContent = document.getElementById('playerContent');
    const musicPlayer = document.getElementById('musicPlayer');
    const radioChatWrapper = document.getElementById('radioChatWrapper');
    
    // Radio server configuration
    // For local network access, use your local IP (192.168.86.28)
    // For internet access via ngrok, the code will auto-detect the ngrok URL
    
    // LOCAL NETWORK ACCESS (same WiFi/network):
    const LOCAL_IP = '192.168.86.28'; // Your local network IP
    
    // Auto-detect: use localhost if on same machine, otherwise use local IP
    let RADIO_HOST = LOCAL_IP;
    let RADIO_PORT = 8000;
    let USE_HTTPS = false;
    
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || window.location.hostname === '') {
      RADIO_HOST = 'localhost';
    }
    
    // Try to auto-detect ngrok URL (if ngrok is running)
    async function detectNgrokUrl() {
      // If site is HTTPS, we MUST use HTTPS for the stream (ngrok provides this)
      // Try to detect ngrok, but if on HTTPS site, we can't access localhost API due to CORS
      const isHttpsSite = window.location.protocol === 'https:';
      
      if (isHttpsSite) {
        // On HTTPS site, we need to use ngrok HTTPS URL
        // Since we can't access localhost API from HTTPS, we'll try common ngrok patterns
        // OR you can manually set the ngrok URL below
        console.log('Site is HTTPS - must use HTTPS stream (ngrok)');
        
        // Option: Manually set your ngrok URL here if you know it
        // Uncomment and set your ngrok URL:
        // const MANUAL_NGROK_URL = 'https://kam-budless-gael.ngrok-free.dev';
        // if (MANUAL_NGROK_URL) {
        //   RADIO_HOST = MANUAL_NGROK_URL.replace('https://', '').replace('http://', '');
        //   RADIO_PORT = '';
        //   USE_HTTPS = true;
        //   const STREAM_URL = `https://${RADIO_HOST}/stream`;
        //   const STATUS_URL = `https://${RADIO_HOST}/status-json.xsl`;
        //   audio.src = STREAM_URL;
        //   window.STREAM_URL = STREAM_URL;
        //   window.STATUS_URL = STATUS_URL;
        //   console.log('Using manual ngrok URL:', STREAM_URL);
        //   return true;
        // }
      }
      
      // Try to access ngrok API (only works from HTTP/localhost)
      try {
        const response = await fetch('http://127.0.0.1:4040/api/tunnels');
        const data = await response.json();
        
        if (data.tunnels && data.tunnels.length > 0) {
          // Find the tunnel that forwards to localhost:8000
          const tunnel = data.tunnels.find(t => 
            t.config.addr && t.config.addr.includes('8000')
          ) || data.tunnels[0]; // Fallback to first tunnel
          
          if (tunnel && tunnel.public_url) {
            const ngrokUrl = tunnel.public_url;
            console.log('Auto-detected ngrok URL:', ngrokUrl);
            
            // Use ngrok URL
            RADIO_HOST = ngrokUrl.replace('https://', '').replace('http://', '');
            RADIO_PORT = '';
            USE_HTTPS = ngrokUrl.startsWith('https://');
            
            // Update audio source
            const PROTOCOL = USE_HTTPS ? 'https' : 'http';
            const PORT_STRING = RADIO_PORT ? `:${RADIO_PORT}` : '';
            const STREAM_URL = `${PROTOCOL}://${RADIO_HOST}${PORT_STRING}/stream`;
            const STATUS_URL = `${PROTOCOL}://${RADIO_HOST}${PORT_STRING}/status-json.xsl`;
            
            audio.src = STREAM_URL;
            window.STREAM_URL = STREAM_URL;
            window.STATUS_URL = STATUS_URL;
            
            console.log('Radio server URL (ngrok):', STREAM_URL);
            return true;
          }
        }
      } catch (err) {
        // ngrok not running or not accessible (CORS on HTTPS sites)
        if (isHttpsSite) {
          console.log('On HTTPS site - cannot access ngrok API. Please set ngrok URL manually in code.');
        } else {
          console.log('ngrok not detected, using local network:', err.message);
        }
      }
      return false;
    }
    
    // Initialize radio URLs
    let STREAM_URL, STATUS_URL;
    
    // If site is HTTPS, we MUST use HTTPS stream (ngrok)
    const isHttpsSite = window.location.protocol === 'https:';
    
    // Try to get ngrok URL from Firebase (auto-updates without code changes)
    async function getNgrokUrlFromFirebase() {
      try {
        const { getDoc, doc } = await import("https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js");
        const { db } = await import('./firebase.js');
        const configDoc = await getDoc(doc(db, 'config', 'radio'));
        if (configDoc.exists()) {
          const data = configDoc.data();
          if (data.ngrokUrl) {
            console.log('Got ngrok URL from Firebase:', data.ngrokUrl);
            return data.ngrokUrl;
          }
        }
      } catch (err) {
        console.log('Could not get ngrok URL from Firebase:', err.message);
      }
      return null;
    }
    
    // Try to detect ngrok first, then fall back to Firebase, then local network
    detectNgrokUrl().then(async (ngrokFound) => {
      if (!ngrokFound) {
        // Try to get from Firebase
        const firebaseNgrokUrl = await getNgrokUrlFromFirebase();
        
        if (firebaseNgrokUrl) {
          // Use ngrok URL from Firebase
          RADIO_HOST = firebaseNgrokUrl.replace('https://', '').replace('http://', '');
          RADIO_PORT = '';
          USE_HTTPS = firebaseNgrokUrl.startsWith('https://');
          STREAM_URL = `${USE_HTTPS ? 'https' : 'http'}://${RADIO_HOST}/stream`;
          STATUS_URL = `${USE_HTTPS ? 'https' : 'http'}://${RADIO_HOST}/status-json.xsl`;
          audio.src = STREAM_URL;
          window.STREAM_URL = STREAM_URL;
          window.STATUS_URL = STATUS_URL;
          console.log('Using ngrok URL from Firebase:', STREAM_URL);
        } else if (isHttpsSite) {
          // HTTPS site needs HTTPS stream - warn user
          console.error('ERROR: HTTPS site requires ngrok URL. Please set it in Firebase config/radio document.');
          console.error('Create a document at: config/radio with field: ngrokUrl = "https://your-ngrok-url.ngrok-free.dev"');
        } else {
          // Use local network (only works on HTTP sites or localhost)
          const PROTOCOL = USE_HTTPS ? 'https' : 'http';
          const PORT_STRING = RADIO_PORT ? `:${RADIO_PORT}` : '';
          STREAM_URL = `${PROTOCOL}://${RADIO_HOST}${PORT_STRING}/stream`;
          STATUS_URL = `${PROTOCOL}://${RADIO_HOST}${PORT_STRING}/status-json.xsl`;
          audio.src = STREAM_URL;
          window.STREAM_URL = STREAM_URL;
          window.STATUS_URL = STATUS_URL;
          console.log('Radio server URL (local network):', STREAM_URL);
        }
      }
    });
    
    // Set initial URLs (will be updated if ngrok is found)
    const PROTOCOL = USE_HTTPS ? 'https' : 'http';
    const PORT_STRING = RADIO_PORT ? `:${RADIO_PORT}` : '';
    STREAM_URL = `${PROTOCOL}://${RADIO_HOST}${PORT_STRING}/stream`;
    STATUS_URL = `${PROTOCOL}://${RADIO_HOST}${PORT_STRING}/status-json.xsl`;
    window.STREAM_URL = STREAM_URL;
    window.STATUS_URL = STATUS_URL;
    
    let isPlaying = false;
    let isMinimized = false;
    let streamIsLive = false;
    
    // Initialize audio - will be updated when ngrok is detected
    audio.volume = 0.8;
    
    // Wait for ngrok detection before setting audio source
    detectNgrokUrl().then(() => {
      const finalStreamUrl = window.STREAM_URL || STREAM_URL;
      audio.src = finalStreamUrl;
      console.log('Audio source set to:', finalStreamUrl);
      // Check stream status after setting source
      setTimeout(() => checkStreamStatus(), 1000);
    });
    
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    let xOffset = 0;
    let yOffset = 0;

    const playerHeader = document.getElementById('playerHeader');
    const chatContainer = document.getElementById('chatContainer');

    // Ensure chat container is visible on page load
    if (chatContainer) {
      chatContainer.style.display = 'flex';
    }

    // Set default centered position if no saved position exists
    const savedLeft = localStorage.getItem('radioChatWrapperLeft');
    const savedTop = localStorage.getItem('radioChatWrapperTop');
    if (!savedLeft || !savedTop) {
      // Center the radio vertically and horizontally on page load
      const centerX = window.innerWidth / 2 - 250; // 250 is half of 500px width
      const centerY = window.innerHeight / 2 - 200; // Approximate center (adjust as needed)
      radioChatWrapper.style.setProperty('left', centerX + 'px', 'important');
      radioChatWrapper.style.setProperty('top', centerY + 'px', 'important');
      radioChatWrapper.style.setProperty('position', 'absolute', 'important');
    } else {
      // Load saved position
      radioChatWrapper.style.setProperty('left', savedLeft, 'important');
      radioChatWrapper.style.setProperty('top', savedTop, 'important');
      radioChatWrapper.style.setProperty('position', 'absolute', 'important');
    }

    // Make both header and chat container draggable
    playerHeader.addEventListener('mousedown', dragStart);
    if (chatContainer) {
      chatContainer.addEventListener('mousedown', dragStart);
    }
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', dragEnd);

    function dragStart(e) {
      // Don't drag if clicking buttons or input fields
      if (e.target.classList.contains('minimize-btn') || 
          e.target.tagName === 'BUTTON' || 
          e.target.tagName === 'INPUT' ||
          e.target.closest('button') ||
          e.target.closest('input')) {
        return;
      }
      
      // Get current position of the wrapper
      const rect = radioChatWrapper.getBoundingClientRect();
      initialX = e.clientX - rect.left;
      initialY = e.clientY - rect.top;
      isDragging = true;
      
      if (e.target.closest('#playerHeader')) {
        playerHeader.style.cursor = 'grabbing';
      }
      if (chatContainer) {
        chatContainer.style.cursor = 'grabbing';
      }
    }

    function drag(e) {
      if (isDragging) {
        e.preventDefault();
        
        // Calculate new position relative to document (not viewport)
        currentX = e.clientX - initialX + window.scrollX;
        currentY = e.clientY - initialY + window.scrollY;
        
        // Update position - use absolute positioning relative to document
        radioChatWrapper.style.setProperty('left', currentX + 'px', 'important');
        radioChatWrapper.style.setProperty('top', currentY + 'px', 'important');
        radioChatWrapper.style.setProperty('position', 'absolute', 'important');
      }
    }

    function dragEnd(e) {
      if (isDragging) {
        // Store final position relative to document
        const finalX = e.clientX - initialX + window.scrollX;
        const finalY = e.clientY - initialY + window.scrollY;
        radioChatWrapper.style.setProperty('left', finalX + 'px', 'important');
        radioChatWrapper.style.setProperty('top', finalY + 'px', 'important');
        // Save position to localStorage
        localStorage.setItem('radioChatWrapperLeft', finalX + 'px');
        localStorage.setItem('radioChatWrapperTop', finalY + 'px');
      }
      isDragging = false;
      playerHeader.style.cursor = 'move';
      if (chatContainer) {
        chatContainer.style.cursor = 'default';
      }
    }
    
    async function checkStreamStatus() {
      // CORS prevents fetch requests, so we rely entirely on audio element events
      // HTML5 audio can play streams even with CORS errors
      const streamUrl = window.STREAM_URL || STREAM_URL;
      
      // Ensure audio source is set
      if (streamUrl && (!audio.src || audio.src !== streamUrl)) {
        audio.src = streamUrl;
        console.log('Audio source set to:', streamUrl);
      }
      
      // Check audio element state to determine if stream is live
      // If audio is playing or ready, stream is likely live
      if (!audio.paused && !audio.ended && audio.readyState >= 2) {
        if (!streamIsLive) {
          streamIsLive = true;
          document.getElementById('playerStatus').innerHTML = '● LIVE';
          console.log('Stream detected as LIVE (audio playing)');
        }
        return true;
      }
      
      // If audio has an error and it's not just loading, stream might be offline
      // But we can't reliably detect offline state without fetch, so we'll be optimistic
      // User can try to play and audio events will handle it
      
      return streamIsLive;
    }
    
    function updateTrackInfo(title) {
      const trackElement = document.querySelector('.player-track');
      if (trackElement) {
        if (title && title.trim() && title !== 'Live Radio Stream' && title !== 'unknown' && title.trim() !== '') {
          trackElement.textContent = title.trim();
        } else {
          // Don't change to "No track info available" if we already have a song name
          if (trackElement.textContent === 'Waiting for stream...' || !trackElement.textContent || trackElement.textContent.trim() === '') {
            trackElement.textContent = "No track info available";
          }
        }
      }
    }
    
    // Fetch track info immediately
    async function fetchTrackInfo() {
      const statusUrl = window.STATUS_URL || STATUS_URL;
      if (!statusUrl) {
        console.log('[Track Info] No STATUS_URL available');
        return;
      }
      
      try {
        console.log('[Track Info] Fetching from:', statusUrl);
        // Use simple request to avoid preflight OPTIONS check
        // Simple requests don't trigger preflight if they don't have custom headers
        const response = await fetch(statusUrl + '?nocache=' + Date.now(), {
          method: 'GET',
          cache: 'no-cache',
          mode: 'cors'
        });
        
        console.log('[Track Info] Response status:', response.status, response.statusText);
        
        if (!response.ok) {
          console.log('[Track Info] Response not OK:', response.status);
          return;
        }
        
        const data = await response.json();
        console.log('[Track Info] Received data:', data);
        
        if (data.icestats && data.icestats.source) {
          const stream = Array.isArray(data.icestats.source) 
            ? data.icestats.source[0] 
            : data.icestats.source;
          
          console.log('[Track Info] Stream object:', stream);
          
          if (stream) {
            // Try multiple possible fields for track title
            let trackTitle = null;
            
            if (stream.title && stream.title.trim()) {
              trackTitle = stream.title.trim();
            } else if (stream.yp_currently_playing && stream.yp_currently_playing.trim()) {
              trackTitle = stream.yp_currently_playing.trim();
            } else if (stream.server_name) {
              trackTitle = stream.server_name;
            }
            
            console.log('[Track Info] Found track title:', trackTitle);
            
            if (trackTitle && trackTitle !== lastTrackTitle) {
              console.log('[Track Info] Updating to:', trackTitle);
              lastTrackTitle = trackTitle;
              updateTrackInfo(trackTitle);
            } else if (!trackTitle) {
              console.log('[Track Info] No track title found in stream data');
            }
          } else {
            console.log('[Track Info] No stream object found');
          }
        } else {
          console.log('[Track Info] No icestats.source found in response');
        }
      } catch (err) {
        // Log the actual error for debugging
        console.error('[Track Info] Fetch error:', err);
        console.error('[Track Info] Error details:', {
          message: err.message,
          name: err.name,
          stack: err.stack
        });
        
        // Only show error message once to avoid spam
        if (!window.trackInfoErrorLogged) {
          console.log('[Track Info] CORS or network error');
          console.log('[Track Info] Since headers are configured, try:');
          console.log('[Track Info] 1. Hard refresh the page (Ctrl+F5)');
          console.log('[Track Info] 2. Clear browser cache');
          console.log('[Track Info] 3. Check if ngrok URL changed');
          window.trackInfoErrorLogged = true;
        }
        
        // Clear "Loading track info..." if we hit an error
        const trackEl = document.querySelector('.player-track');
        if (trackEl && trackEl.textContent === 'Loading track info...') {
          trackEl.textContent = 'Track info unavailable';
        }
      }
    }
    
    let lastTrackTitle = '';
    
    // Real-time status and track info updates - check every 2 seconds
    setInterval(async () => {
      const wasLive = streamIsLive;
      await checkStreamStatus();
      
      // Update status display based on audio state
      if (audio.readyState >= 2 && !audio.paused && !audio.ended) {
        streamIsLive = true;
        if (isPlaying) {
          document.getElementById('playerStatus').innerHTML = '● LIVE';
        } else if (streamIsLive) {
          document.getElementById('playerStatus').innerHTML = '● LIVE';
        }
      } else if (audio.error || (audio.readyState === 0 && wasLive)) {
        streamIsLive = false;
        if (isPlaying) {
          stopStream();
        }
        document.getElementById('playerStatus').innerHTML = '⚫ OFFLINE';
        document.querySelector('.player-track').textContent = 'Stream offline';
      }
      
      // Always try to fetch track info when stream is live or playing
      if (streamIsLive || isPlaying || (!audio.paused && !audio.ended)) {
        fetchTrackInfo();
      }
    }, 2000); // Check every 2 seconds for faster updates
    
    checkStreamStatus();
    
    audio.addEventListener('loadstart', function() {
      console.log('Stream loading...');
      document.getElementById('playerStatus').innerHTML = '⏳ LOADING...';
    });

    audio.addEventListener('canplay', function() {
      console.log('Stream ready to play');
      streamIsLive = true;
      const statusEl = document.getElementById('playerStatus');
      if (statusEl) statusEl.innerHTML = '● LIVE';
      // Try to fetch track info when stream is ready
      fetchTrackInfo();
    });

    audio.addEventListener('waiting', function() {
      console.log('Stream buffering...');
      if (streamIsLive) {
        document.getElementById('playerStatus').innerHTML = '⏳ BUFFERING...';
      }
    });

    audio.addEventListener('playing', function() {
      streamIsLive = true;
      isPlaying = true;
      const statusEl = document.getElementById('playerStatus');
      if (statusEl) {
        statusEl.innerHTML = '● LIVE';
      }
      if (playBtn) {
        playBtn.innerHTML = '⏸';
      }
      // Fetch track info immediately when playing starts
      fetchTrackInfo();
    });

    audio.addEventListener('error', function(e) {
      console.error('Stream error:', e);
      streamIsLive = false;
      isPlaying = false;
      const statusEl = document.getElementById('playerStatus');
      if (statusEl) statusEl.innerHTML = '⚫ OFFLINE';
      const trackEl = document.querySelector('.player-track');
      if (trackEl) trackEl.textContent = 'Stream error';
      if (playBtn) playBtn.innerHTML = '▶';
    });
    
    function togglePlay() {
      if (isPlaying) {
        audio.pause();
        if (playBtn) playBtn.innerHTML = '▶';
        const statusEl = document.getElementById('playerStatus');
        if (statusEl) statusEl.innerHTML = '⏸ PAUSED';
        isPlaying = false;
      } else {
        const streamUrl = window.STREAM_URL || STREAM_URL;
        
        // Set audio source - HTML5 audio can play streams even with CORS issues
        if (!audio.src || audio.src !== streamUrl) {
          audio.src = streamUrl;
          console.log('Setting audio source:', streamUrl);
        }
        
        // Try to play - audio element works even with CORS errors
        const statusEl = document.getElementById('playerStatus');
        if (statusEl) statusEl.innerHTML = '⏳ LOADING...';
        
        const playPromise = audio.play();
        if (playPromise !== undefined) {
          playPromise.then(() => {
            streamIsLive = true;
            isPlaying = true;
            if (playBtn) playBtn.innerHTML = '⏸';
            if (statusEl) statusEl.innerHTML = '● LIVE';
            console.log('Playback started successfully');
            // Clear "Waiting for stream..." and fetch track info immediately
            const trackEl = document.querySelector('.player-track');
            if (trackEl && trackEl.textContent === 'Waiting for stream...') {
              trackEl.textContent = 'Loading track info...';
            }
            // Fetch track info immediately when play succeeds
            setTimeout(() => fetchTrackInfo(), 500);
          }).catch(err => {
            console.error('Play failed:', err);
            streamIsLive = false;
            isPlaying = false;
            if (statusEl) statusEl.innerHTML = '⚫ OFFLINE';
            const trackEl = document.querySelector('.player-track');
            if (trackEl) trackEl.textContent = 'Stream offline';
            
            // Try loading and playing again after a short delay
            setTimeout(() => {
              audio.load();
              audio.play().then(() => {
                playBtn.innerHTML = '⏸';
                streamIsLive = true;
                document.getElementById('playerStatus').innerHTML = '● LIVE';
                isPlaying = true;
              }).catch(err2 => {
                console.error('Retry play also failed:', err2);
                document.getElementById('playerStatus').innerHTML = '⚫ OFFLINE';
                streamIsLive = false;
                alert('Unable to connect to stream. Make sure the stream is live.');
              });
            }, 2000);
          });
        }
      }
    }
    
    function stopStream() {
      audio.pause();
      audio.load();
      streamIsLive = false;
      isPlaying = false;
      if (playBtn) playBtn.innerHTML = '▶';
      const statusEl = document.getElementById('playerStatus');
      if (statusEl) statusEl.innerHTML = '⚫ OFFLINE';
      const trackEl = document.querySelector('.player-track');
      if (trackEl) trackEl.textContent = 'Stream stopped';
    }
    
    function changeVolume(val) {
      audio.volume = val / 100;
      document.getElementById('volumeDisplay').innerHTML = val;
    }
    
    function toggleMinimize() {
      isMinimized = !isMinimized;
      const chatContainer = document.getElementById('chatContainer');
      if (isMinimized) {
        playerContent.style.display = 'none';
        musicPlayer.style.height = '30px';
        if (chatContainer) {
          chatContainer.style.display = 'none';
        }
      } else {
        playerContent.style.display = 'block';
        musicPlayer.style.height = 'auto';
        if (chatContainer) {
          chatContainer.style.display = 'flex';
        }
      }
    }
    
    // Ensure chat container is visible on page load (in case it was minimized)
    window.addEventListener('DOMContentLoaded', function() {
      const chatContainer = document.getElementById('chatContainer');
      if (chatContainer && !isMinimized) {
        chatContainer.style.display = 'flex';
      }
    });
    
    function previousTrack() {
      stopStream();
      setTimeout(() => togglePlay(), 500);
    }
    
    function nextTrack() {
      stopStream();
      setTimeout(() => togglePlay(), 500);
    }
  </script>
</body>
</html>